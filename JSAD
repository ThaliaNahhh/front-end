1. 基础总结深入

	1.1 数据类型
		1.1.1 分类
				基本值类型：String	任意字符串
							Number	任意数字
							boolean	true/false
							undefined	undefined
							null	null
				对象（引用）类型：Object 	任意对象
								  Function	特别对象，可执行
								  Array		特别对象，数值下标，内部数据有序。
		1.1.2 判断
				typeof	返回数据类型的字符串表达。
						可以判断：undefined/数字/字符串/布尔值。
						不能判断：null与object 	object与array
					eg. 
						'''js
							var a;
							console.log(a, typeof a, typeof a==='undefined', a===undefined);	//undefined 'undefined' true true
							console.log(undefined==='undefined');
							
							a = 3;
							console.log(type a==='number');
							
							
							a = null;
							console.log(typeof a, a===null);    //'object'  true
						'''
				instanceof	判断对象具体类型：object、array、function。
							console.log(b1.b2 instanceof Function, b1.b2 instanceof Object);	//true true
				===			可以判断undefined, null。(因为这两个类型只有一个值)。
				
	tips：undefined与null的区别。
			undefined:定义未赋值。
			null:定义并赋值，但值为null。初始赋值表明要赋值为对象，结束赋值表明成为垃圾对象待回收。
				var b = null;	//初始值为null，暗示定义一个对象，确定对象就赋值。
				b = ['123', 12];
				b = null;		//让b指向的对象成为垃圾对象，等待被浏览器中的垃圾回收器回收。
		  区分变量类型与数据类型：
			数据的类型：
				基本类型：
				对象类型：
			变量类型：（变量内存值的区别）
				基本类型：保存基本类型数据值
				引用类型：保存地址值
				
				
	tip:实例对象
		实例：实例对象
		类型：类型对象
		function Abc(name, age){
			this.name = name;
		}							//构造函数：类型（是一种对象，因为函数本身是一个对象）；
		var p = new Abc("tom");		//根据类型创建的实例对象
	
	1.2 数据、内存、变量
		数据：存储在内存中代表特定信息的东西，本质上是二进制字符串。
				特点：可传递；可运算；
				一切皆数据，内存中所有操作（算术、逻辑、赋值、运行函数）目标都是数据，一定数据类型可执行的操作不变。
		内存：内存条通电以后产生的可存储数据的空间（临时的）。
				内存产生与死亡：内存条（电路板）->通电->产生内存空间->存储数据->处理数据->断电->内存空间和数据消失。
				内存分类：	栈：全局变量/局部变量
							堆:	对象 
		变量：可变化的量，由变量名和变量值组成，每个变量对应一块内存，变量名用于查找对应的内存。

		
2. 函数高级

	2.1 原型与原型链
		2.1.1	函数的prototype属性
				
				每个函数都有一个prototype属性，默认指向一个object空对象，即原型对象。
				原型对象中有一个属性constructor，指向函数对象。
				
				|Type    	   				|	|Type prototype	   		 |
				|prototype|指针指向prototype|   |constructor|指针指向Type|
				
				给原型对象添加属性（一般是方法）->实例对象可以访问。
		
		2.1.2	显式原型与隐式原型
		
				function Fn(){	//内部语句：this.prototype = {}
				
				}//定义构造函数
				var fn = new Fn();	//内部语句：this.__proto__ = Fn.prototype;
				console.log(Fn.prototype===fn.__proto__);	//true
				
				每个函数function都有一个prototype，即显式原型（属性）。
				每个实例对象都有一个__proto__，即隐式原型（属性）。
				对象的隐式原型的值为其对应构造函数的显式原型的值。
				
				Fn.prototype.test = function(){
					console.log("test!");
				}//给函数原型添加方法。
				fn.test();	
				
				总结：函数的prototype属性在定义函数时自动添加，默认值是一个空的Object对象。
					  对象的__proto__属性是创建对象时自动添加的，默认值是构造函数的prototype属性值。
					  es6之前程序员可以直接操作显式原型，但不能直接操作隐式原型（用于测试或输出）。
		2.1.3 原型链（隐式原型链）：用于查找对象的属性。
				访问一个对象的属性时，先在自身属性中查找，找到返回，若没有，再沿着__proto__链向上查找，找到返回；
				若最终未找到，返回undefined。
		2.1.4 补充
				所有函数的显式原型属性默认指向空的Object对象，但Object不满足。
				所有函数都是Function的实例（包括Function本身）。
				Object的原型对象是原型链尽头。
				
		2.1.5 属性问题：
				读取对象的属性时，会自动到原型链中查找。
				设置对象的属性时，不会自动到原型链中查找，如果当前对象中没有该属性，直接添加该属性并设置值。
				方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。
		2.1.6 探索instanceof
				instanceof是如何判断的？
					表达式：A instanceof B;		A:实例对象（__proto__属性）	B：构造函数（prototype属性）
					如果B函数的显式原型对象在A对象的原型链上返回true，否则false。
					console.log(object instanceof Function);	//true	Object.__proto__ = Function.prototype
					console.log(Object instanceof Object);	//true		Object.__proto__ = Function.prototype Function.prototype.__proto__ == Object.prototype,所有函数的显式原型指向空的Obj对象
					console.log(Function instanceof Function);	//true	Function.__proto__ == Function.prototype	Function是通过new本身产生的实例。
					console.log(Function instanceof Object);	//true	Function.__proto__ = Function.prototype Function.prototype.__proto__ == Object.prototype 
					console.log(object instanceof Foo);	//false		Object.__proto__ = Function.prototype Function.prototype.__proto__ = Object.prototype	Foo.prototype = Object != Object.prototype
					
				Function是通过new Function本身产生的实例。
	2.2 执行上下文与执行上下文栈
		2.2.1 变量提升与函数提升
				变量的声明提前（变量提升）：
					使用var关键字声明的变量会在所有代码执行之前被声明，但会在执行到当前行时赋值；
					如果声明变量时不使用var关键字则不会被声明提前。
					
					即var变量在定义语句前就可访问（值：undefined）。
					
					若未使用var会如下所示：
					
					'''js
						console.log(a);
						a = 3;	//Uncaught ReferenceError: a is not defined
					'''
				函数的声明提前（函数提升）：
					使用函数声明形式创建的函数 function 函数(){}，它会在所有代码执行之前就被创建（即声明提前，创建提前），
					使用函数表达式创建的函数不会被提前创建。
					
					即可以在函数声明之前调用。
					
					tips: 
						'''js
							fn();	//undefined, 因为这个是变量提升而非函数提升。
							var fn = Function(){};
				问题：这二者是如何产生的？
		2.2.2 执行上下文
				代码分类（位置）：
					全局代码
					局部代码（函数代码）
				
				全局执行上下文：
					1.在执行全局代码前，将window确定为全局执行上下文
					2.对全局数据进行预处理
						var定义的全局变量->undefined，添加为window属性
						function声明的全局函数->赋值（fun），添加为window方法
						this->赋值为window
					3.开始执行全局代码
				函数执行上下文：
					1.在调用函数准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）
					2.对局部数据进行预处理
						形参变量->赋值（实参）->添加为执行上下文的属性
						arguments（类数组）->赋值（实参列表）->添加为执行上下文的属性
						var定义的局部变量->undefined->添加为执行上下文的属性
						function声明的函数->赋值（fun）->添加为执行上下文的方法
						this->赋值(调用函数的对象)
					3.开始执行函数体代码
		2.2.3 执行上下文栈
				在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象。
				而后每创建一个上下文就入栈一个，结束一段就出栈一个。
	2.3 作用域与作用域链
		2.3.1 作用域
				理解：静态概念，编写代码时就确定了。它是一块“地盘”，代码段所在的区域。
				分类：	全局作用域
						函数作用域
						没有块作用域（现在没有 es6有）
				作用：隔离变量，不同作用域下同名变量不会有冲突。
				数量：n+1原则，针对定义函数的块数。
					
，		2.3.2 作用域与执行上下文
				区别：	1.全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时已确定，而非调用时。
						2.全局执行上下文环境是在全局作用域确定之后，js代码马上执行前创建。
						3.函数执行上下文是在调用函数时，函数体代码执行之前创建的。
						
						1.作用域是静态的，函数定义好了就存在，且不会再变化。
						2.执行上下文是动态的，调用函数时创建，函数调用结束时自动释放
						
				联系：	执行上下文从属于所在的作用域.
		2.3.3 作用域链
				从内向外。
	2.4 闭包
		2.4.1 如何产生闭包
				当一个嵌套的内部函数引用了嵌套的外部函数的变量（函数）时，就产生了闭包。
				执行函数定义就会产生闭包，不用调用函数。
			  何为闭包
				a.闭包是嵌套的内部函数
				b.包含被引用变量（函数）的对象
				tips:闭包存在于嵌套的内部函数中。
		      产生条件
				函数嵌套
				内部函数引用了外部函数的数据（变量/函数）
		2.4.2 常见的闭包
				1.将函数作为另一个函数的返回值
				'''js
					function fn1(){
						var a = 2;
						function fn2(){     //执行函数定义就会产生闭包，不用调用函数
							a++;
							console.log(a);
						}
						return fn2;
					}
					var f = fn1();
					f();    //3
					f();    //4 
					//产生了几个闭包就看调用了几次外部函数，这个例子中产生了一个闭包。
				'''
				2.将函数作为实参传递给另一个函数调用
		2.4.3 闭包的作用
				1.使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生存周期）。
				2.让函数外部可以操作（读写）到函数内部的数据（变量/函数）。
				
				问题：
				1.函数执行完后，函数内部声明的变量是否还存在？
					一般不存在，存在于闭包中的变量才可能存在（如果将对象返回给新的变量的话。）
				2.在函数外部能直接访问函数内部的局部变量吗？
					不能，但可以通过闭包让外部操作它。
		2.4.4 闭包的生命周期
				产生：在嵌套内部函数定义执行完后就产生了（而非调用）
				死亡：在嵌套的内部函数成为垃圾对象时
		2.4.5 闭包的应用
				定义JS模块
					具有特定功能的js文件，将所有数据和功能都封装在一个函数内部（私有的）；
				只向外暴露一个包含n个方法的对象或函数，模块的使用者只需要通过模块暴露的对象调用方法来实现相应功能。
		2.4.6 闭包的缺点及解决
				缺点：函数执行完后，函数内部的局部变量没有释放，占用内存时间变长，容易造成内存泄漏。
				解决：尽量避免使用闭包，或及时释放（f = null）
				
3. 对象高级

	3.1	对象创建模式
		3.1.1 Object构造函数模式
			方法：先创建空Object对象，再添加属性/方法
			适用场景：起始时对象内部数据不确定
			问题：语句过多

		3.1.2 对象字面量模式
			方法：使用{}创建对象，同时指定属性/方法
			适用场景：起始时对象内部数据确定
			问题：如果创建多个对象，代码重复
		3.1.3 工厂模式
			方法：通过工厂函数动态创建对象并返回
			适用场景：需要创建多个对象
			问题：对象无具体类型，都是Object类型
		3.1.4 自定义构造函数模式
			方法：自定义构造函数模式
			适用场景：需要创建多个类型确定的对象
			问题：每个对象都有相同的数据，浪费内存
		3.1.5 构造函数+原型的组合模式
			方法：自定义构造函数，属性在函数中初始化，方法添加至原型
			适用场景：需要创建多个类型确定的对象
	3.2 继承模式
		3.2.1 原型链继承：得到方法
			方法：	1.定义父类型构造函数
					2.给父类型的原型添加方法
					3.定义子类型的构造函数
					4.创建父类型的对象，赋值给子类型原型
					5.将子类型原型的构造属性设置为子类型
					6.给子类型原型添加方法
					7.创建子类型的对象：可以调用父类型的方法
			关键：	*子类型的原型是父类型的一个实例对象*
					Sub.prototype = new Supper();
					让子类型的原型的constructor指向子类型
					Sub.prototype.constructor = Sub;
		3.2.2 借用构造函数继承：得到属性
			方法：	1.定义父类型构造函数
					2.定义子类型构造函数
					3.在子类型构造函数中调用父类型构造
			关键：	在子类型构造函数中通用call()调用父类型构造函数
		3.2.3 组合继承
			方法：	1.利用原型链实现对父类型对象方法的继承
					2.利用call()借用父类型构建函数初始化相同属性
			
	3.3 new一个对象的过程
			创造一个空对象；
			给对象设置__proto__，值为构造函数的prototype属性值；
			执行构造函数体（给对象添加属性/方法）。
			
4. 线程机制与事件机制

	4.1 进程与线程
		4.1.1 进程
				进程的一次执行过程。
		4.1.2 线程
				线程池：保存多个线程对象的容器，实现线程对象的复用。
				JS：单线程运行，但使用H5中的Web Workers可以多线程运行。
				浏览器：多线程；
				浏览器：单进程(firefox,老版本ie)/多进程(chrome、新版ie);
						查看方法：任务管理器
	4.2 浏览器内核
			定义：支撑浏览器运行的最核心程序
			例如：Chrome, Safari: webkit
					firefox: Gecko
				ie: Trident
				360,搜狗等国内浏览器：Trident + webkit
			内核由很多程序组成：
				1. js引擎模块：负责js程序的编译与运行
				2. html、css文档解析模块：负责页面文本的解析
				3. dom/css模块：负责dom/css在内存中的相关处理
				4. 布局和渲染模块：负责页面的布局和效果绘制（内存中的对象）。
				————以上为主线程————
				……
				定时器模块：负责定时器管理
				DOM事件响应模块：负责事件管理
				网络请求模块：负责ajax请求
				————以上为分线程————
	4.3 定时器思考
		定时器真的是定时执行的嘛？无法保证真正的定时执行，一般会有延迟，或长或短。
	4.4 js：单线执行
		如何证明单线程？
			setTimeout()的回调函数是在主线程执行的。
			定时器回调函数只有在运行栈的代码全部执行完后才有可能执行。
		为什么js使用单线程而非多线程？
			与其用途有关：主要用来与用户互动以及操作DOM,否则同步问题很复杂。
			
		tips: alert：暂停当前主线程的执行，同时暂停计时，点击确认后恢复程序执行和计时。
		
		代码的分类：
			初始化代码
			回调代码
		js引擎执行代码基本流程：
			初始化代码===>回调代码
			1. 先执行初始化代码:包含一些特别的代码
					设定定时器
					绑定监听
					发送ajax请求
			2. 后面在某个时刻才会执行回调代码。
		回调函数（异步执行），异步：在初始化代码执行完成以后才会执行。
	4.5 事件循环模型
		4.5.1 模型原理图
		4.5.2 模型的两个组成部分
				事件（定时器/DOM事件/Ajax）管理模块
				回调队列
		4.5.3 相关重要概念
				1. 执行栈 execution stack：所有代码的执行空间
				2. 浏览器内核：browser core
								js引擎模块（主线程处理）
								其他模块（主/分线程处理）
				3. 任务队列/消息队列/事件队列：都指的是callback queue
				4. 事件轮询 eventloop：从任务队列中循环去除回调函数，放入执行栈处理
				5. 事件驱动模型 event-driven interaction model
				6. 请求响应模型 request-response model
	4.6 H5 web worker（多线程）
		4.6.1 介绍
				web workers是html5提供的一个js多线程解决方案，可将大计算量代码交给web worker计算而不冻结用户界面。
				但子线程完全受主线程控制，且不得操作DOM。因此未改变js单线程的本质。
		4.6.2 使用
				创建在分线程执行的js文件，在主线程中的js中发消息并设置回调。
		4.6.3 图解
		4.6.4 应用
				直接在主线程，使用worker实现分线程。
		4.6.5 不足
				慢；
				不能跨域加载js；
				worker内代码不能访问window从而更新界面（分线程的全局变量不再是window，无法更新界面）；
				不是每个浏览器都支持。
				
5. 补充

	5.1 分号问题
	5.2 设置
	5.3 内存溢出与内存泄漏
		内存溢出：一种程序运行的错误，当程序需要的内存超过了剩余的内存时，抛出内存溢出的错误。
		内存泄漏：占用内存没有及时释放。内存泄漏积累多了就容易导致内存溢出。
			常见的内存泄漏：意外的全局变量；
							没有及时清理的计时器或回调函数；
							闭包。
